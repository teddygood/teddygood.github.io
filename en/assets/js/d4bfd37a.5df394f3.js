"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[5584],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}},36890:e=>{e.exports=JSON.parse('{"permalink":"/en/blog/Linked-List","editUrl":"https://github.com/teddygood/teddygood.github.io/tree/main/blog/2025-11-14-Linked-List/2025-11-14-Linked-List.md","source":"@site/i18n/en/docusaurus-plugin-content-blog/2025-11-14-Linked-List/2025-11-14-Linked-List.md","title":"\ud83e\udd14Linked lists are used in scenarios where frequent insertions or deletions are required, dynamic memory allocation is needed, or efficient cache utilization is less critical. Common applications include:  \\n1. **Implementation of dynamic data structures** (e.g., stacks, queues, graphs).  \\n2. **Memory management** (e.g., free store/malloc implementation).  \\n3. **Undo/Redo functionality** in applications (e.g., text editors).  \\n4. **Hash tables** with chaining for collision resolution.  \\n5. **Real-time systems** where predictable memory allocation is essential.  \\n6. **Large data sets** where contiguous memory allocation (e.g., arrays) is impractical.  \\n\\nThey are also useful when the size of the data structure is unknown or changes frequently. However, they are less efficient for random access or cache-friendly operations compared to arrays.","description":"Things I looked up while studying linked lists out of curiosity","date":"2025-11-14T16:11:00.000Z","tags":[{"inline":true,"label":"Dev","permalink":"/en/blog/tags/dev"}],"hasTruncateMarker":true,"authors":[{"name":"Chanho Lee","title":"\ub2e4\uc591\ud55c \ubd84\uc57c\ub97c \uacf5\ubd80\ud558\uace0 \uc788\ub294 \ud559\uc0dd","url":"https://github.com/teddygood","imageURL":"https://github.com/teddygood.png","key":"teddygood","page":null}],"frontMatter":{"authors":"teddygood","date":"2025-11-14 16:11","description":"Things I looked up while studying linked lists out of curiosity","draft":false,"slug":"/Linked-List","tags":["Dev"],"title":"\ud83e\udd14Linked lists are used in scenarios where frequent insertions or deletions are required, dynamic memory allocation is needed, or efficient cache utilization is less critical. Common applications include:  \\n1. **Implementation of dynamic data structures** (e.g., stacks, queues, graphs).  \\n2. **Memory management** (e.g., free store/malloc implementation).  \\n3. **Undo/Redo functionality** in applications (e.g., text editors).  \\n4. **Hash tables** with chaining for collision resolution.  \\n5. **Real-time systems** where predictable memory allocation is essential.  \\n6. **Large data sets** where contiguous memory allocation (e.g., arrays) is impractical.  \\n\\nThey are also useful when the size of the data structure is unknown or changes frequently. However, they are less efficient for random access or cache-friendly operations compared to arrays."},"unlisted":false,"nextItem":{"title":"\ud83d\udcd6AI Engineering","permalink":"/en/blog/ai-engineering"}}')},96097:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=n(36890),o=n(74848),s=n(28453);const a={authors:"teddygood",date:"2025-11-14 16:11",description:"Things I looked up while studying linked lists out of curiosity",draft:!1,slug:"/Linked-List",tags:["Dev"],title:"\ud83e\udd14Linked lists are used in scenarios where frequent insertions or deletions are required, dynamic memory allocation is needed, or efficient cache utilization is less critical. Common applications include:  \n1. **Implementation of dynamic data structures** (e.g., stacks, queues, graphs).  \n2. **Memory management** (e.g., free store/malloc implementation).  \n3. **Undo/Redo functionality** in applications (e.g., text editors).  \n4. **Hash tables** with chaining for collision resolution.  \n5. **Real-time systems** where predictable memory allocation is essential.  \n6. **Large data sets** where contiguous memory allocation (e.g., arrays) is impractical.  \n\nThey are also useful when the size of the data structure is unknown or changes frequently. However, they are less efficient for random access or cache-friendly operations compared to arrays."},r=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){return(0,o.jsx)(o.Fragment,{})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d()}}}]);