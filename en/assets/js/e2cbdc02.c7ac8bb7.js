"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[9032],{19151(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});var i=t(36890),s=t(74848),l=t(28453);const o={authors:"teddygood",date:"2025-11-14 16:11",description:"Things I looked up while studying linked lists out of curiosity",draft:!1,slug:"/Linked-List",tags:["Dev"],title:"Why Linked Lists Are Rarely Used in Python"},r=void 0,d={authorsImageUrls:[void 0]},a=[{value:"Introduction",id:"introduction",level:2},{value:"Why Linked Lists Are Rarely Used in Python",id:"why-linked-lists-are-rarely-used-in-python",level:2},{value:"Dynamic Arrays",id:"dynamic-arrays",level:3},{value:"Cache Locality",id:"cache-locality",level:3},{value:"PyObject and Memory Overhead",id:"pyobject-and-memory-overhead",level:3},{value:"Cases Where Linked Lists Are Used in Python",id:"cases-where-linked-lists-are-used-in-python",level:2},{value:"Python <code>functools.lru_cache</code> Double Linked List",id:"python-functoolslru_cache-double-linked-list",level:3},{value:"Python <code>weakref</code> Module",id:"python-weakref-module",level:3},{value:"Python <code>asyncio</code> Event Loop",id:"python-asyncio-event-loop",level:3},{value:"Other Cases Where Linked Lists Are Used",id:"other-cases-where-linked-lists-are-used",level:2},{value:"Python <code>OrderedDict</code> Double Linked List",id:"python-ordereddict-double-linked-list",level:3},{value:"Redis Sorted Set with Skip List and Double Linked List",id:"redis-sorted-set-with-skip-list-and-double-linked-list",level:3},{value:"glibc <code>malloc</code> Free List",id:"glibc-malloc-free-list",level:3},{value:"libstdc++ <code>unordered_map</code> Chaining",id:"libstdc-unordered_map-chaining",level:3},{value:"Linux Kernel Intrusive Doubly Linked List",id:"linux-kernel-intrusive-doubly-linked-list",level:3},{value:"Chromium <code>base::LinkedList</code> Intrusive List",id:"chromium-baselinkedlist-intrusive-list",level:3},{value:"Summary",id:"summary",level:2},{value:"Implementation Examples",id:"implementation-examples",level:2},{value:"Python",id:"python",level:3},{value:"C++",id:"c",level:3},{value:"References",id:"references",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["When studying data structures and algorithms, one inevitably learns about linked lists. However, in my development experience or when solving practical problems, I rarely had to implement or use linked lists directly. After learning the basic concepts long ago, I had almost no practical use cases for them. Even while preparing for coding tests recently, I rarely encountered problems that required linked lists. When I did, I mostly solved them using Python's ",(0,s.jsx)(n.code,{children:"deque"}),', and my understanding was limited to the superficial knowledge that "linked lists are inefficient in Python."']}),"\n",(0,s.jsx)(n.p,{children:'This led me to revisit linked lists and ask a fundamental question: "Why are linked lists not used often?" Simply attributing it to "inefficiency in Python" felt insufficient, so I wanted to investigate and organize the actual reasons. This post summarizes my research and reflections on the topic.'}),"\n",(0,s.jsx)(n.h2,{id:"why-linked-lists-are-rarely-used-in-python",children:"Why Linked Lists Are Rarely Used in Python"}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:'This is not a claim that linked lists are never used. The title was changed from "Reasons Not to Use Linked Lists" to "Reasons Why Linked Lists Seem Not to Be Used" to reflect this.'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"English comments in the code are from the original source."})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-arrays",children:"Dynamic Arrays"}),"\n",(0,s.jsxs)(n.p,{children:["In Python, linked lists are rarely used because the built-in ",(0,s.jsx)(n.code,{children:"list"})," is implemented as a dynamic array, providing many of the advantages of linked lists. According to the CPython FAQ, a list is a contiguous array of pointers to other objects, and the list header contains a pointer to this array and its length. This structure ensures that accessing an element by index ",(0,s.jsx)(n.code,{children:"a[i]"})," is always O(1), regardless of the list size."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Array"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Index access: O(1)"}),"\n",(0,s.jsx)(n.li,{children:"Contiguous memory"}),"\n",(0,s.jsx)(n.li,{children:"Insertion/deletion in the middle: O(n)"}),"\n",(0,s.jsx)(n.li,{children:"Appending at the end: Amortized O(1)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Linked List"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Index access: O(n)"}),"\n",(0,s.jsx)(n.li,{children:"Scattered memory"}),"\n",(0,s.jsx)(n.li,{children:"Insertion/deletion (given a node): O(1)"}),"\n",(0,s.jsx)(n.li,{children:"Finding the insertion position: O(n)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This is structurally similar to C's arrays and C++'s ",(0,s.jsx)(n.code,{children:"std::vector"}),". Below is the ",(0,s.jsx)(n.code,{children:"PyListObject"})," definition from ",(0,s.jsx)(n.code,{children:"cpython/Include/cpython/listobject.h"}),". The key part is ",(0,s.jsx)(n.code,{children:"PyObject **ob_item"}),", which stores pointers to Python objects in a contiguous array."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"typedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 <= ob_size <= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"ob_item"})," is allocated using ",(0,s.jsx)(n.code,{children:"malloc"}),". When ",(0,s.jsx)(n.code,{children:"append()"})," is called and the array is full, reallocation occurs. CPython uses a strategy to pre-allocate extra space to make multiple append operations efficient."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"cpython/Objects/lisobject.c"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"...\nitems = PyMem_New(PyObject*, size);\n...\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"cpython/include/pymem.h"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#define PyMem_New(type, n) \\\n  ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \\\n        ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"cpython/Objects/obmalloc.c"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void *\nPyMem_Malloc(size_t size)\n{\n    /* see PyMem_RawMalloc() */\n    if (size > (size_t)PY_SSIZE_T_MAX)\n        return NULL;\n    OBJECT_STAT_INC_COND(allocations512, size < 512);\n    OBJECT_STAT_INC_COND(allocations4k, size >= 512 && size < 4094);\n    OBJECT_STAT_INC_COND(allocations_big, size >= 4094);\n    OBJECT_STAT_INC(allocations);\n    return _PyMem.malloc(_PyMem.ctx, size);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cache-locality",children:"Cache Locality"}),"\n",(0,s.jsx)(n.p,{children:"Cache locality is an important factor that makes dynamic arrays more efficient than linked lists, not just in Python but also in C++."}),"\n",(0,s.jsx)(n.p,{children:"Theoretically, linked list insertions and deletions are O(1), but actual performance is heavily influenced by memory access patterns. CPUs have caches (L1, L2, L3) that are much faster than main memory (RAM). Accessing L1 cache takes about 1\u20132 ns, while accessing main memory takes about 60\u2013100 ns. Modern CPUs prefetch adjacent memory when accessing a location, leading to cache hits for contiguous memory like arrays. Linked lists, with scattered memory, often result in cache misses."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Array Example"}),(0,s.jsx)(n.br,{}),"\n","Memory addresses: 1000   1008   1016   1024",(0,s.jsx)(n.br,{}),"\n","Pointers: [ptr0] [ptr1] [ptr2] [ptr3] (contiguous memory)",(0,s.jsx)(n.br,{}),"\n","Sequential access has high cache hit rates."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Linked List Example"}),(0,s.jsx)(n.br,{}),"\n","Memory addresses: 1000        5432        2048        7890",(0,s.jsx)(n.br,{}),"\n","Nodes: Node(1) \u2192 Node(2) \u2192 Node(3) \u2192 Node(4)",(0,s.jsx)(n.br,{}),"\n","Each node access may cause a cache miss."]}),"\n",(0,s.jsxs)(n.p,{children:["Thus, arrays have near O(1) access due to cache hits, while linked lists suffer from O(n) access due to cache misses. This is why ",(0,s.jsx)(n.code,{children:"std::vector"})," is preferred over ",(0,s.jsx)(n.code,{children:"std::list"})," in C++ and Python's ",(0,s.jsx)(n.code,{children:"list"})," over linked lists."]}),"\n",(0,s.jsx)(n.h3,{id:"pyobject-and-memory-overhead",children:"PyObject and Memory Overhead"}),"\n",(0,s.jsxs)(n.p,{children:["In Python, all values are represented as ",(0,s.jsx)(n.code,{children:"PyObject"})," structures. Below is the ",(0,s.jsx)(n.code,{children:"PyObject"})," definition from ",(0,s.jsx)(n.code,{children:"cpython/Include/object.h"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// PyObject base structure\nstruct _object {\n    _Py_ANONYMOUS union {\n#if SIZEOF_VOID_P > 4 // 64-bit system\n        PY_INT64_T ob_refcnt_full; /* For efficient initialization with Clang on ARM */ // 8 bytes\n        struct {\n#  if PY_BIG_ENDIAN\n            uint16_t ob_flags; // 2 bytes\n            uint16_t ob_overflow; // 2 bytes\n            uint32_t ob_refcnt; // 4 bytes (reference count)\n#  else\n            uint32_t ob_refcnt;      \n            uint16_t ob_overflow;\n            uint16_t ob_flags;\n#  endif\n        }; // Union size is 8 bytes\n#else\n        Py_ssize_t ob_refcnt;\n#endif\n        _Py_ALIGNED_DEF(_PyObject_MIN_ALIGNMENT, char) _aligner;\n    };\n    PyTypeObject *ob_type;           // 8 bytes (type pointer)\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Every Python object includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reference count: 8 bytes (union size)"}),"\n",(0,s.jsx)(n.li,{children:"Type pointer: 8 bytes (64-bit system)"}),"\n",(0,s.jsx)(n.li,{children:"Total: 16 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"C++ Node vs Python Node Comparison"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// C++ Node structure\nstruct Node {\n    int val;        // 4 bytes\n    // Padding: 4 bytes (for 8-byte alignment on 64-bit systems)\n    Node* next;     // 8 bytes (64-bit pointer)\n    Node(int v) : val(v), next(nullptr) {} // Constructor stored in code segment\n};\n\nNode node(1);       // Instance creation\n// Total: 16 bytes\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python\nclass Node:\n    def __init__(self, val): # Constructor stored in class\n        self.val = val\n        self.next = None\n\nnode = Node(1)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In Python, object attributes are stored in a ",(0,s.jsx)(n.code,{children:"__dict__"})," dictionary. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"print(node.__dict__)  # {'val': 1, 'next': None}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Thus, the total memory usage includes both the object itself and the ",(0,s.jsx)(n.code,{children:"__dict__"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import sys\nprint(sys.getsizeof(node))          # Object itself: 48 bytes\nprint(sys.getsizeof(node.__dict__)) # Attribute dictionary: 64 bytes\n# Total: 112 bytes (may vary by version)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For cases requiring insertions/deletions at both ends, Python's ",(0,s.jsx)(n.code,{children:"collections.deque"})," is more efficient. Deque is a hybrid structure of linked lists and arrays, allowing O(1) operations at both ends while maintaining cache efficiency. Below is the deque structure from ",(0,s.jsx)(n.code,{children:"cpython/Modules/_collectionsmodule.c"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#define BLOCKLEN 64  // Each block size\n\n// Block structure - doubly linked list node\ntypedef struct BLOCK {\n    struct BLOCK *leftlink;      // Previous block pointer\n    PyObject *data[BLOCKLEN];    // Array of 64 PyObject pointers\n    struct BLOCK *rightlink;     // Next block pointer\n} block;\n\nstruct dequeobject {\n    PyObject_VAR_HEAD\n    block *leftblock;\n    block *rightblock;\n    Py_ssize_t leftindex;       /* 0 <= leftindex < BLOCKLEN */\n    Py_ssize_t rightindex;      /* 0 <= rightindex < BLOCKLEN */\n    size_t state;               /* Incremented when indices move */\n    Py_ssize_t maxlen;          /* -1 for unbounded deques */\n    Py_ssize_t numfreeblocks;\n    block *freeblocks[MAXFREEBLOCKS];\n    PyObject *weakreflist;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each block is a doubly linked list node containing a fixed-size array. This structure allows O(1) operations at both ends while maintaining cache efficiency. However, deque has slightly more memory overhead than ",(0,s.jsx)(n.code,{children:"list"}),", and middle insertions/deletions are still O(n), with indexing being O(1) only at the ends."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from collections import deque\n\n# Deque creation\ndq = deque([1, 2, 3])\n\n# O(1) operations at both ends\ndq.append(4)        # Right append: [1, 2, 3, 4]\ndq.appendleft(0)    # Left append: [0, 1, 2, 3, 4]\ndq.pop()            # Right pop: [0, 1, 2, 3]\ndq.popleft()        # Left pop: [1, 2, 3]\n\n# Indexing (O(1) at ends, O(n) in the middle)\nprint(dq[0]) # 1 - Left end, O(1) \nprint(dq[-1]) # 3 - Right end, O(1) \nprint(dq[1]) # 2 - Middle, O(n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Thus, ",(0,s.jsx)(n.code,{children:"deque"})," is suitable for stack/queue-like operations at the ends, while ",(0,s.jsx)(n.code,{children:"list"})," is better for random access or middle insertions/deletions."]}),"\n",(0,s.jsx)(n.h2,{id:"cases-where-linked-lists-are-used-in-python",children:"Cases Where Linked Lists Are Used in Python"}),"\n",(0,s.jsx)(n.p,{children:"Despite the above, linked lists are still useful in specific scenarios. Below are examples from Python's standard library and other systems."}),"\n",(0,s.jsxs)(n.h3,{id:"python-functoolslru_cache-double-linked-list",children:["Python ",(0,s.jsx)(n.code,{children:"functools.lru_cache"})," Double Linked List"]}),"\n",(0,s.jsxs)(n.p,{children:["Python's ",(0,s.jsx)(n.code,{children:"functools.lru_cache"})," uses a circular doubly linked list to implement LRU caching. The dictionary alone cannot track usage order, and using an array would make middle insertions/deletions O(n). The linked list allows O(1) operations when combined with a dictionary for O(1) lookups."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n    # Constants shared by all lru cache instances:\n    sentinel = object()          # Unique object for cache misses\n    make_key = _make_key         # Build a key from function arguments\n    PREV, NEXT, KEY, RESULT = 0, 1, 2, 3   # Names for link fields\n\n    cache = {}\n    hits = misses = 0\n    full = False\n    cache_get = cache.get    # Bound method to lookup a key or return None\n    cache_len = cache.__len__  # Get cache size without calling len()\n    lock = RLock()           # Because linkedlist updates aren't threadsafe\n    root = []                # Root of the circular doubly linked list -> Sentinel node\n    root[:] = [root, root, None, None]     # Initialize by pointing to self\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The sentinel node (",(0,s.jsx)(n.code,{children:"root"}),") points to itself when the list is empty, simplifying edge cases. The dictionary provides O(1) lookups, and the linked list manages usage order. When a new item is added, it is inserted right after the root. When an existing item is accessed, it is moved to the front. If the cache is full, the least recently used item (root's previous node) is removed in O(1) time."]}),"\n",(0,s.jsxs)(n.h3,{id:"python-weakref-module",children:["Python ",(0,s.jsx)(n.code,{children:"weakref"})," Module"]}),"\n",(0,s.jsxs)(n.p,{children:["Python's ",(0,s.jsx)(n.code,{children:"weakref"})," module uses linked lists to manage weak references. When an object is deleted, all weak references to it must be invalidated. The linked list allows O(1) removal when combined with a dictionary for O(1) lookups."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"/* PyWeakReference is the base struct for Python ReferenceType, ProxyType, and CallableProxyType. */\nstruct _PyWeakReference {\n    PyObject_HEAD\n\n    /* The object to which this is a weak reference, or Py_None if none.\n     * Note that this is a stealth reference:  wr_object's refcount is\n     * not incremented to reflect this pointer.\n     */\n    PyObject *wr_object;\n\n    /* A callable to invoke when wr_object dies, or NULL if none. */\n    PyObject *wr_callback;\n\n    /* Cache for wr_object's hash code. -1 if not known yet. */\n    Py_hash_t hash;\n\n    /* If wr_object is weakly referenced, it has a doubly-linked NULL-terminated\n     * list of weak references. These are the list pointers.\n     * If wr_object goes away, wr_object is set to Py_None, and these pointers\n     * have no meaning then.\n     */\n    PyWeakReference *wr_prev;\n    PyWeakReference *wr_next;\n    vectorcallfunc vectorcall;\n\n#ifdef Py_GIL_DISABLED\n    /* Pointer to the lock used when clearing in free-threaded builds.\n     * Normally this can be derived from wr_object, but in some cases we need\n     * to lock after wr_object has been set to Py_None.\n     */\n    PyMutex *weakrefs_lock;\n#endif\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"wr_prev"})," and ",(0,s.jsx)(n.code,{children:"wr_next"})," pointers form a doubly linked list of weak references. When an object is deleted, the list is traversed to invalidate all weak references and call their callbacks."]}),"\n",(0,s.jsxs)(n.h3,{id:"python-asyncio-event-loop",children:["Python ",(0,s.jsx)(n.code,{children:"asyncio"})," Event Loop"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"asyncio"})," event loop uses ",(0,s.jsx)(n.code,{children:"deque"})," for the ",(0,s.jsx)(n.code,{children:"_ready"})," queue, which is a hybrid of linked lists and arrays. The ",(0,s.jsx)(n.code,{children:"_ready"})," deque allows O(1) operations at both ends, while the ",(0,s.jsx)(n.code,{children:"_scheduled"})," list uses a heap for time-based sorting."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class BaseEventLoop(events.AbstractEventLoop):\n    def __init__(self):\n        self._ready = collections.deque()  # Ready callbacks\n        self._scheduled = []  # Time-sorted heap\n        # ...\n\n    def call_soon(self, callback, *args, context=None):\n        """Arrange for a callback to be called as soon as possible."""\n        self._check_closed()\n        if self._debug:\n            self._check_thread()\n            self._check_callback(callback, \'call_soon\')\n        handle = self._call_soon(callback, args, context)\n        if handle._source_traceback:\n            del handle._source_traceback[-1]\n        return handle\n\n    def _call_soon(self, callback, args, context):\n        handle = events.Handle(callback, args, self, context)\n        if handle._source_traceback:\n            del handle._source_traceback[-1]\n        self._ready.append(handle)  # O(1) append to deque\n        return handle\n\n    def _run_once(self):\n        """Run one full iteration of the event loop."""\n        # Move timed-out scheduled callbacks to ready\n        ready = self._ready\n        self._ready = collections.deque()\n        end_time = self.time()\n        while self._scheduled:\n            handle = self._scheduled[0]\n            if handle._when > end_time:\n                break\n            handle = heapq.heappop(self._scheduled)\n            ready.append(handle)\n\n        # ready is deque for efficient O(1) operations at both ends\n        ntodo = len(ready)\n        for _ in range(ntodo):\n            handle = ready.popleft()\n            if not handle._cancelled:\n                handle._run()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"_ready"})," deque is a block-based linked list, while ",(0,s.jsx)(n.code,{children:"_scheduled"})," is a heap implemented as a dynamic array. This design leverages the strengths of both structures."]}),"\n",(0,s.jsx)(n.h2,{id:"other-cases-where-linked-lists-are-used",children:"Other Cases Where Linked Lists Are Used"}),"\n",(0,s.jsxs)(n.h3,{id:"python-ordereddict-double-linked-list",children:["Python ",(0,s.jsx)(n.code,{children:"OrderedDict"})," Double Linked List"]}),"\n",(0,s.jsxs)(n.p,{children:["Before Python 3.7, dictionaries did not preserve insertion order, so ",(0,s.jsx)(n.code,{children:"OrderedDict"})," was used. The C implementation in ",(0,s.jsx)(n.code,{children:"cpython/Objects/odictobject.c"})," uses a doubly linked list to maintain order."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"/* PyODictObject */\nstruct _odictobject {\n    PyDictObject od_dict;        /* Underlying dict */\n    _ODictNode *od_first;        /* First node in the linked list, if any */\n    _ODictNode *od_last;         /* Last node in the linked list, if any */\n    /* od_fast_nodes, od_fast_nodes_size, and od_resize_sentinel are managed\n     * by _odict_resize().\n     * Note that we rely on implementation details of dict for both. */\n    _ODictNode **od_fast_nodes;  /* Hash table mirroring the dict table */\n    Py_ssize_t od_fast_nodes_size;\n    void *od_resize_sentinel;    /* Changes if odict should be resized */\n\n    size_t od_state;             /* Incremented whenever the LL changes */\n    PyObject *od_inst_dict;      /* OrderedDict().__dict__ */\n    PyObject *od_weakreflist;    /* Holds weakrefs to the odict */\n};\n\n...\n\nstruct _odictnode {\n    PyObject *key;\n    Py_hash_t hash;\n    _ODictNode *next;\n    _ODictNode *prev;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"od_fast_nodes"})," array mirrors the dictionary's hash table, allowing O(1) lookups while maintaining insertion order via the linked list."]}),"\n",(0,s.jsx)(n.h3,{id:"redis-sorted-set-with-skip-list-and-double-linked-list",children:"Redis Sorted Set with Skip List and Double Linked List"}),"\n",(0,s.jsx)(n.p,{children:"Redis uses a skip list with backward pointers (a doubly linked list at level 1) for sorted sets. This allows O(log N) range queries and O(1) reverse traversal."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'/* ZSETs are ordered sets using two data structures to hold the same elements\n * in order to get O(log(N)) INSERT and REMOVE operations into a sorted\n * data structure.\n *\n * The elements are added to a hash table mapping Redis objects to scores.\n * At the same time the elements are added to a skip list mapping scores\n * to Redis objects (so objects are sorted by scores in this "view").\n *\n * This skiplist implementation is almost a C translation of the original\n * algorithm described by William Pugh in "Skip Lists: A Probabilistic\n * Alternative to Balanced Trees", modified in three ways:\n * a) this implementation allows for repeated scores.\n * b) the comparison is not just by key (our \'score\') but by satellite data.\n * c) there is a back pointer, so it\'s a doubly linked list with the back\n * pointers being only at level 1. This allows to traverse the list\n * from tail to head, useful for ZREVRANGE. */\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The backward pointer at level 1 enables reverse traversal for commands like ",(0,s.jsx)(n.code,{children:"ZREVRANGE"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"glibc-malloc-free-list",children:["glibc ",(0,s.jsx)(n.code,{children:"malloc"})," Free List"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"malloc"}),"/",(0,s.jsx)(n.code,{children:"free"})," implementation in glibc uses a linked list to manage free memory blocks. The next pointer is stored in the first few bytes of the free block, eliminating the need for additional memory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// Free memory block linked list\nstruct malloc_chunk {\n  INTERNAL_SIZE_T mchunk_prev_size;  /* Previous chunk size */\n  INTERNAL_SIZE_T mchunk_size;       /* Current chunk size */\n  struct malloc_chunk* fd;           /* Forward link - next free block */\n  struct malloc_chunk* bk;           /* Backward link - previous free block */\n  struct malloc_chunk* fd_nextsize;  /* Next size for large chunks */\n  struct malloc_chunk* bk_nextsize;  /* Previous size for large chunks */\n};\n\n// Remove a free chunk from the list - O(1) operation\nstatic void\nunlink_chunk (mstate av, mchunkptr p)\n{\n  mchunkptr fd = p->fd;  // Pointer re-linking\n  mchunkptr bk = p->bk;  // O(1) removal\n  fd->bk = bk;\n  bk->fd = fd;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This design avoids extra memory allocation by storing pointers within the free blocks themselves."}),"\n",(0,s.jsxs)(n.h3,{id:"libstdc-unordered_map-chaining",children:["libstdc++ ",(0,s.jsx)(n.code,{children:"unordered_map"})," Chaining"]}),"\n",(0,s.jsxs)(n.p,{children:["The C++ standard library's ",(0,s.jsx)(n.code,{children:"std::unordered_map"})," uses chaining with linked lists to resolve hash collisions. This allows O(1) insertions in the case of collisions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Single linked list for collision resolution\nstruct _Hash_node_base {\n  _Hash_node_base* _M_nxt;  // Next node pointer\n\n  _Hash_node_base() noexcept : _M_nxt() { }\n  _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }\n};\n\n// Node storing the actual value\ntemplate<typename _Value, bool _Cache_hash_code>\nstruct _Hash_node : _Hash_node_base,\n                    _Hash_node_value<_Value, _Cache_hash_code> {\n  _Hash_node* _M_next() const noexcept {\n    return static_cast<_Hash_node*>(this->_M_nxt);\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each bucket points to a linked list of colliding elements, allowing efficient insertions."}),"\n",(0,s.jsx)(n.h3,{id:"linux-kernel-intrusive-doubly-linked-list",children:"Linux Kernel Intrusive Doubly Linked List"}),"\n",(0,s.jsxs)(n.p,{children:["The Linux kernel provides an intrusive doubly linked list in ",(0,s.jsx)(n.code,{children:"include/linux/list.h"}),". This design allows any structure with a ",(0,s.jsx)(n.code,{children:"list_head"})," field to be part of a linked list."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"struct list_head {\n    struct list_head *next, *prev;\n};\n\n// Initialization - self-referential\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list) {\n    WRITE_ONCE(list->next, list);\n    WRITE_ONCE(list->prev, list);\n}\n\n// O(1) insertion\nstatic inline void __list_add(struct list_head *new,\n                struct list_head *prev,\n                struct list_head *next) {\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    WRITE_ONCE(prev->next, new);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This intrusive design allows the same list operations to be reused across different data structures, such as task scheduling and memory management."}),"\n",(0,s.jsxs)(n.h3,{id:"chromium-baselinkedlist-intrusive-list",children:["Chromium ",(0,s.jsx)(n.code,{children:"base::LinkedList"})," Intrusive List"]}),"\n",(0,s.jsxs)(n.p,{children:["Chromium uses its own ",(0,s.jsx)(n.code,{children:"base::LinkedList"})," implementation, which is intrusive and allows O(1) deletions without needing to search for the element."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Chromium\'s intrusive linked list implementation\ntemplate <typename T>\nclass LinkedList {\n public:\n  // The "root" node is self-referential, forming the basis of a circular list.\n  LinkedList() { root_.set(&root_, &root_); }\n  LinkedList(const LinkedList&) = delete;\n  LinkedList& operator=(const LinkedList&) = delete;\n  \n  // Move constructor (use with care if nodes are stack-allocated)\n  LinkedList(LinkedList&& other) : root_(std::move(other.root_)) {\n    other.root_.MakeSelfReferencing();\n  }\n\n  // Appends |e| to the end of the linked list\n  void Append(LinkNode<T>* e) { e->InsertBefore(&root_); }\n\n  LinkNode<T>* head() const { return root_.next(); }\n\n  LinkNode<T>* tail() const { return root_.previous(); }\n\n  const LinkNode<T>* end() const { return &root_; }\n\n  bool empty() const { return head() == end(); }\n\n private:\n  LinkNode<T> root_;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"This design avoids the overhead of reallocating and copying elements, making it suitable for scenarios where multiple iterators need to remain valid during modifications."}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["While linked lists are rarely used directly in Python for general-purpose programming, they are still essential in specific scenarios and system-level implementations. The built-in ",(0,s.jsx)(n.code,{children:"list"})," and ",(0,s.jsx)(n.code,{children:"deque"})," provide most of the functionality needed for everyday tasks, but linked lists shine in cases requiring efficient insertions/deletions at known positions or when memory constraints demand intrusive designs."]}),"\n",(0,s.jsx)(n.p,{children:"The main takeaway is that unless a problem explicitly requires implementing a linked list, it's unlikely you'll need to use one in coding tests or general development. However, understanding their strengths and weaknesses is crucial for designing efficient systems."}),"\n",(0,s.jsx)(n.p,{children:"Below is a comparison of time complexity and implementation examples in Python and C++."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.code,{children:"list"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.code,{children:"deque"})}),(0,s.jsx)(n.th,{children:"Custom Linked List"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Append"}),(0,s.jsx)(n.td,{children:"O(1) amortized"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(n) (find end)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Prepend"}),(0,s.jsx)(n.td,{children:"O(n)"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(1)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pop from end"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(n) (find end)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pop from front"}),(0,s.jsx)(n.td,{children:"O(n)"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(1)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Index access"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"O(n)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Memory efficiency"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Low"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Cache efficiency"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Low"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-examples",children:"Implementation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None  # Each node has its value and a pointer to the next node\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None  # Pointer to the first node\n\n    def insert_front(self, val):\n        node = Node(val)\n        node.next = self.head\n        self.head = node\n\n    def insert_back(self, val):\n        # If the list is empty, set head to the new node\n        if not self.head:\n            self.head = Node(val)\n            return\n        # Traverse to the end\n        cur = self.head\n        while cur.next:\n            cur = cur.next\n        cur.next = Node(val)\n\n    def delete(self, val):\n        # If the list is empty, return\n        if not self.head:\n            return\n        # If the head is the target, remove it\n        if self.head.val == val:\n            self.head = self.head.next\n            return\n        # Traverse to find the node before the target\n        cur = self.head\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n                return\n            cur = cur.next\n"})}),"\n",(0,s.jsx)(n.h3,{id:"c",children:"C++"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node* next;\n    Node(int v) : val(v), next(nullptr) {}\n};\n\nclass LinkedList {\npublic:\n    Node* head;\n    \n    LinkedList() : head(nullptr) {}\n    \n    // Insert at the front\n    void insert_front(int val) {\n        Node* node = new Node(val);\n        node->next = head;\n        head = node;\n    }\n    \n    // Insert at the end\n    void insert_back(int val) {\n        if (head == nullptr) {\n            head = new Node(val);\n            return;\n        }\n        Node* cur = head;\n        while (cur->next != nullptr) {\n            cur = cur->next;\n        }\n        cur->next = new Node(val);\n    }\n    \n    // Delete a value\n    void delete_value(int val) {\n        if (head == nullptr)\n            return;\n            \n        // If head is the target\n        if (head->val == val) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n            return;\n        }\n        \n        // Traverse to find the node before the target\n        Node* cur = head;\n        while (cur->next != nullptr) {\n            if (cur->next->val == val) {\n                Node* temp = cur->next;\n                cur->next = cur->next->next;\n                delete temp;\n                return;\n            }\n            cur = cur->next;\n        }\n    }\n    \n    // Print the list\n    void print() {\n        Node* cur = head;\n        while (cur != nullptr) {\n            cout << cur->val << " -> ";\n            cur = cur->next;\n        }\n        cout << "NULL\\n";\n    }\n};\n\nint main() {\n    LinkedList list;\n\n    list.insert_front(3);\n    list.insert_front(2);\n    list.insert_front(1);\n\n    list.insert_back(4);\n    list.insert_back(5);\n\n    list.print(); // 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n\n    list.delete_value(3);\n    list.print(); // 1 -> 2 -> 4 -> 5 -> NULL\n\n    list.delete_value(1);\n    list.print(); // 2 -> 4 -> 5 -> NULL\n\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/python/cpython",children:"CPython GitHub"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.python.org/3/faq/design.html#how-are-lists-implemented-in-cpython",children:"CPython Design and History FAQ"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://gist.github.com/jboner/2841832",children:"Latency Numbers Every Programmer Should Know"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory",children:"Approximate cost to access various caches and main memory - Stack Overflow"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/redis/redis/",children:"Redis GitHub"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/torvalds/linux",children:"Linux Kernel GitHub"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>o,x:()=>r});var i=t(96540);const s={},l=i.createContext(s);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(l.Provider,{value:n},e.children)}},36890(e){e.exports=JSON.parse('{"permalink":"/en/blog/Linked-List","editUrl":"https://github.com/teddygood/teddygood.github.io/tree/main/blog/2025-11-14-Linked-List/2025-11-14-Linked-List.md","source":"@site/i18n/en/docusaurus-plugin-content-blog/2025-11-14-Linked-List/2025-11-14-Linked-List.md","title":"Why Linked Lists Are Rarely Used in Python","description":"Things I looked up while studying linked lists out of curiosity","date":"2025-11-14T16:11:00.000Z","tags":[{"inline":true,"label":"Dev","permalink":"/en/blog/tags/dev"}],"hasTruncateMarker":true,"authors":[{"name":"Chanho Lee","title":"\ub2e4\uc591\ud55c \ubd84\uc57c\ub97c \uacf5\ubd80\ud558\uace0 \uc788\ub294 \ud559\uc0dd","url":"https://github.com/teddygood","imageURL":"https://github.com/teddygood.png","key":"teddygood","page":null}],"frontMatter":{"authors":"teddygood","date":"2025-11-14 16:11","description":"Things I looked up while studying linked lists out of curiosity","draft":false,"slug":"/Linked-List","tags":["Dev"],"title":"Why Linked Lists Are Rarely Used in Python"},"unlisted":false,"prevItem":{"title":"[Paper Review] OrchestrationBench: LLM-Driven Agentic Planning and Tool Use in Multi-Domain Scenarios","permalink":"/en/blog/OrchestrationBench"},"nextItem":{"title":"\ud83d\udcd6AI Engineering","permalink":"/en/blog/ai-engineering"}}')}}]);